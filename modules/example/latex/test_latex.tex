\documentclass{report}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{amsmath}
\setlength{\parindent}{15pt}
\geometry{a4paper,top=2cm,bottom=3cm,left=2cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\usepackage{xcolor}
\lstset{
	language=C++, 
	basicstyle=\ttfamily\small, 
	keywordstyle=\color{blue}\bfseries, 
	stringstyle=\color{orange}, 
	commentstyle=\color{green!50!black}\itshape, 
	morecomment=[l][\color{purple}]{\#}, 
	tabsize=2, 
	breaklines=true, 
	breakatwhitespace=false, 
	breakindent=0pt,
	frame=single, 
	title=\lstname,
	showstringspaces=false, 
}

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\Large Отчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large \«Реализация параллельного алгоритма Штрассена для умножения матриц\»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнил:} \\
студент группы 3822Б1ПР3 \\
Наседкин Е.Д.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Преподаватели:} \\
Нестеров А.Ю.\\
Оболенский А.А.\\}
\vspace{\fill}

\begin{center} Нижний Новгород \\ 2024 \end{center}

\end{titlepage}

\setcounter{page}{2}

\tableofcontents

\newpage

\section*{Введение} \addcontentsline{toc}{section}{Введение}  
Алгоритм Штрассена \u2014 это метод умножения матриц, который уменьшает вычислительную сложность по сравнению с классическим методом. Его применение особенно эффективно для больших матриц благодаря рекурсивному разбиению задач на подзадачи меньшего размера.

В данной работе реализован параллельный алгоритм Штрассена с использованием библиотеки MPI. Этот подход позволяет использовать преимущества многопроцессорных систем для ускорения вычислений.

\newpage

\section*{Постановка задачи} \addcontentsline{toc}{section}{Постановка задачи}
Целью работы является разработка параллельной версии алгоритма Штрассена для умножения квадратных матриц.

Задачи:
\begin{itemize}
\item Реализовать последовательную и параллельную версии алгоритма Штрассена.
\item Провести тестирование корректности алгоритма.
\end{itemize}

\newpage

\section*{Описание алгоритма Штрассена} \addcontentsline{toc}{section}{Описание алгоритма Штрассена}
Алгоритм Штрассена основывается на разбиении исходных матриц на блоки и выполнении вычислений через промежуточные матрицы. Это позволяет сократить количество операций умножения с 8 до 7 на каждом уровне рекурсии.

\subsection*{Основные этапы алгоритма}
\begin{enumerate}
\item Разбиение исходных матриц на блоки.
\item Вычисление промежуточных матриц $M_1, \dots, M_7$.
\item Объединение результатов для формирования итоговой матрицы.
\end{enumerate}

Параллельная версия алгоритма разделяет вычисления между процессами с использованием MPI, что позволяет выполнять отдельные этапы независимо.

\newpage

\section*{Заключение} \addcontentsline{toc}{section}{Заключение}
В результате работы:
\begin{itemize}
\item Реализованы последовательная и параллельная версии алгоритма Штрассена.
\item Проведено тестирование корректности алгоритма.
\item Достигнуто значительное ускорение на больших матрицах при использовании параллельной версии.
\end{itemize}

Данная работа демонстрирует эффективность использования MPI для реализации алгоритмов линейной алгебры и открывает возможности для их применения в задачах высокопроизводительных вычислений.

\newpage

\begin{thebibliography}{1}
\addcontentsline{toc}{section}{Литература}
\bibitem{strassen_original} Strassen algorithm. Wikipedia. URL: \url{https://en.wikipedia.org/wiki/Strassen_algorithm}.
\bibitem{mpi_documentation} Open MPI Documentation. URL: \url{https://www.open-mpi.org/doc/}.
\bibitem{boost_mpi} Boost.MPI Documentation. URL: \url{https://www.boost.org/doc/libs/release/doc/html/mpi.html}.
\end{thebibliography}

\newpage

\section*{Приложения}
\addcontentsline{toc}{section}{Приложения}

\subsection*{Функция StrassenAlgorithmSEQ::strassen\_multiply\_seq}
\begin{lstlisting}
std::vector<double> StrassenAlgorithmSEQ::strassen_multiply_seq(const std::vector<double>& matrixA,
                                                const std::vector<double>& matrixB, size_t size) {
  if (matrixA.empty() || matrixB.empty() || size == 0) {
    return {};
  }

  if (size == 1) {
    return {matrixA[0] * matrixB[0]};
  }

  size_t new_size = 1;
  while (new_size < size) {
    new_size *= 2;
  }

  size_t half_size = new_size / 2;

  std::vector<double> A11(half_size * half_size);
  std::vector<double> A12(half_size * half_size);
  std::vector<double> A21(half_size * half_size);
  std::vector<double> A22(half_size * half_size);

  std::vector<double> B11(half_size * half_size);
  std::vector<double> B12(half_size * half_size);
  std::vector<double> B21(half_size * half_size);
  std::vector<double> B22(half_size * half_size);

  for (size_t i = 0; i < half_size; ++i) {
    for (size_t j = 0; j < half_size; ++j) {
      A11[i * half_size + j] = matrixA[i * new_size + j];
      A12[i * half_size + j] = matrixA[i * new_size + j + half_size];
      A21[i * half_size + j] = matrixA[(i + half_size) * new_size + j];
      A22[i * half_size + j] = matrixA[(i + half_size) * new_size + j + half_size];

      B11[i * half_size + j] = matrixB[i * new_size + j];
      B12[i * half_size + j] = matrixB[i * new_size + j + half_size];
      B21[i * half_size + j] = matrixB[(i + half_size) * new_size + j];
      B22[i * half_size + j] = matrixB[(i + half_size) * new_size + j + half_size];
    }
  }

  std::vector<std::vector<double>> M(7);
  std::vector<std::vector<double>> tasks = {matrix_add(A11, A22, half_size),
    matrix_add(A21, A22, half_size),
     A11,
    A22,
    matrix_add(A11, A12, half_size),
    matrix_subtract(A21, A11, half_size),
    matrix_subtract(A12, A22, half_size)};

  std::vector<std::vector<double>> tasksB = {
      matrix_add(B11, B22, half_size),      B11, matrix_subtract(B12, B22, half_size),
      matrix_subtract(B21, B11, half_size), B22, matrix_add(B11, B12, half_size),
      matrix_add(B21, B22, half_size)};

  for (int i = 0; i < 7; ++i) {
    M[i] = strassen_recursive(tasks[i], tasksB[i], half_size);
  }

  for (int i = 0; i < 7; ++i) {
    std::vector<double> result;
    M[i] = result;
  }

  std::vector<double> C11 =
      matrix_add(matrix_subtract(matrix_add(M[0], M[3], half_size), M[4], half_size), M[6], half_size);
  std::vector<double> C12 = matrix_add(M[2], M[4], half_size);
  std::vector<double> C21 = matrix_add(M[1], M[3], half_size);
  std::vector<double> C22 =
      matrix_add(matrix_subtract(matrix_add(M[0], M[2], half_size), M[1], half_size), M[5], half_size);

  std::vector<double> result(size * size);
  for (size_t i = 0; i < half_size; ++i) {
    for (size_t j = 0; j < half_size; ++j) {
      result[i * size + j] = C11[i * half_size + j];
      result[i * size + j + half_size] = C12[i * half_size + j];
      result[(i + half_size) * size + j] = C21[i * half_size + j];
      result[(i + half_size) * size + j + half_size] = C22[i * half_size + j];
    }
  }
  return result;
  return {};
}
\end{lstlisting}

\subsection*{Функция StrassenAlgorithmMPI::strassen\_multiply}
\begin{lstlisting}
    std::vector<double> StrassenAlgorithmMPI::strassen_multiply(const std::vector<double>& matrixA,
                                                                const std::vector<double>& matrixB, size_t size) {
      boost::mpi::environment env;
      boost::mpi::communicator world;

      int rank = world.rank();
      int num_procs = world.size();

      if (size == 1) {
        return {matrixA[0] * matrixB[0]};
      }

      size_t new_size = 1;
      while (new_size < size) {
        new_size *= 2;
      }

      size_t half_size = new_size / 2;

        std::vector<double> A11(half_size * half_size);
        std::vector<double> A12(half_size * half_size);
        std::vector<double> A21(half_size * half_size);
        std::vector<double> A22(half_size * half_size);

        std::vector<double> B11(half_size * half_size);
        std::vector<double> B12(half_size * half_size);
        std::vector<double> B21(half_size * half_size);
        std::vector<double> B22(half_size * half_size);

      for (size_t i = 0; i < half_size; ++i) {
        for (size_t j = 0; j < half_size; ++j) {
          A11[i * half_size + j] = matrixA[i * new_size + j];
          A12[i * half_size + j] = matrixA[i * new_size + j + half_size];
          A21[i * half_size + j] = matrixA[(i + half_size) * new_size + j];
          A22[i * half_size + j] = matrixA[(i + half_size) * new_size + j + half_size];

          B11[i * half_size + j] = matrixB[i * new_size + j];
          B12[i * half_size + j] = matrixB[i * new_size + j + half_size];
          B21[i * half_size + j] = matrixB[(i + half_size) * new_size + j];
          B22[i * half_size + j] = matrixB[(i + half_size) * new_size + j + half_size];
        }
      }

        std::vector<std::vector<double>> M(7);
        if (rank == 0) {
          std::vector<std::vector<double>> tasks = {
              matrix_add(A11, A22, half_size),
              matrix_add(A21, A22, half_size),
              A11,
              A22,
              matrix_add(A11, A12, half_size),
              matrix_subtract(A21, A11, half_size),
              matrix_subtract(A12, A22, half_size)
          };

          std::vector<std::vector<double>> tasksB = {
              matrix_add(B11, B22, half_size),
              B11,
              matrix_subtract(B12, B22, half_size),
              matrix_subtract(B21, B11, half_size),
              B22,
              matrix_add(B11, B12, half_size),
              matrix_add(B21, B22, half_size)
          };

          for (int i = 0; i < 7; ++i) {
            if (i % num_procs == 0) {
              M[i] = strassen_recursive(tasks[i], tasksB[i], half_size);
            } else {
              world.send(i % num_procs, i, tasks[i]);
              world.send(i % num_procs, i, tasksB[i]);
            }
          }
        }

        for (int i = 0; i < 7; ++i) {
          if (i % num_procs == rank && i % num_procs != 0) {
            std::vector<double> taskA;
            std::vector<double> taskB;

            world.recv(0, i, taskA);
            world.recv(0, i, taskB);

            M[i] = strassen_recursive(taskA, taskB, half_size);

            world.send(0, i, M[i]);
          }
        }

        if (rank == 0) {
          for (int i = 0; i < 7; ++i) {
            if (i % num_procs != 0) {
              std::vector<double> result;
              world.recv(i % num_procs, i, result);
              M[i] = result;
            }
          }
        }

        if (rank == 0) {

          std::vector<double> C11 =
              matrix_add(matrix_subtract(matrix_add(M[0], M[3], half_size), M[4], half_size), M[6], half_size);
          std::vector<double> C12 = matrix_add(M[2], M[4], half_size);
          std::vector<double> C21 = matrix_add(M[1], M[3], half_size);
          std::vector<double> C22 =
              matrix_add(matrix_subtract(matrix_add(M[0], M[2], half_size), M[1], half_size), M[5], half_size);


          std::vector<double> result(size * size);
          for (size_t i = 0; i < half_size; ++i) {
            for (size_t j = 0; j < half_size; ++j) {
              result[i * size + j] = C11[i * half_size + j];
              result[i * size + j + half_size] = C12[i * half_size + j];
              result[(i + half_size) * size + j] = C21[i * half_size + j];
              result[(i + half_size) * size + j + half_size] = C22[i * half_size + j];
            }
          }
          return result;
        }
        return {};
    }
\end{lstlisting}

\end{document}

